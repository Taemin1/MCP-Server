<!-- html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Tool Test UI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        .status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
        }
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        .status.connecting {
            background: #fff3cd;
            color: #856404;
        }
        .section {
            margin-bottom: 30px;
        }
        .section h2 {
            color: #555;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }
        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
            font-size: 14px;
        }
        .input-group select,
        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        .input-group select:focus,
        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        .output {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            min-height: 150px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .tool-item {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
        }
        .tool-name {
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }
        .tool-description {
            color: #666;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ› ï¸ MCP Tool Test UI</h1>
        <p class="subtitle">Spring AI MCP Server í…ŒìŠ¤íŠ¸ ì¸í„°í˜ì´ìŠ¤</p>

        <div id="status" class="status disconnected">
            âŒ ì—°ê²° ì•ˆë¨
        </div>

        <div class="section">
            <h2>1ï¸âƒ£ ì—°ê²° ì„¤ì •</h2>
            <button onclick="connectSSE()">SSE ì—°ê²°</button>
            <button onclick="disconnect()">ì—°ê²° í•´ì œ</button>
            <div class="output" id="connection-info">ì—°ê²°ì„ ì‹œì‘í•˜ë ¤ë©´ 'SSE ì—°ê²°' ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.</div>
        </div>

        <div class="section">
            <h2>2ï¸âƒ£ Tool ëª©ë¡ ì¡°íšŒ</h2>
            <button onclick="listTools()" id="listToolsBtn" disabled>Tool ëª©ë¡ ë³´ê¸°</button>
            <div class="output" id="tools-output">ì—°ê²° í›„ Tool ëª©ë¡ì„ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</div>
        </div>

        <div class="section">
            <h2>3ï¸âƒ£ Tool í˜¸ì¶œ í…ŒìŠ¤íŠ¸</h2>
            <div class="input-group">
                <label for="toolSelect">Tool ì„ íƒ:</label>
                <select id="toolSelect" onchange="updateInputs()">
                    <option value="">-- Toolì„ ì„ íƒí•˜ì„¸ìš” --</option>
                    <option value="MyFirstToolWorks">MyFirstToolWorks (íŒŒë¼ë¯¸í„° ì—†ìŒ)</option>
                    <option value="getAllUsers">getAllUsers (íŒŒë¼ë¯¸í„° ì—†ìŒ)</option>
                    <option value="getPaginatedUsers">getPaginatedUsers (pageNo,pageSize,properties,direction)</option>
                    <option value="getUserById">getUserById (id)</option>
                    <option value="getUserByUsername">getUserByUsername (username)</option>
                    <option value="getUsersByPlatform">getUsersByPlatform (platform)</option>
                    <option value="removeUserById">removeUserById (id)</option>
                    <option value="removeUserByUsername">removeUserByUsername (username)</option>
                    <option value="createUser">createUser (UserRequestDTO)</option>
                    <option value="changeUserRole">changeUserRole (UserRequestDTO)</option>
                    <option value="checkUserExists">checkUserExists (username)</option>
                </select>
            </div>
            
            <div class="input-group" id="paramsInput" style="display:none;">
                <label for="paramsJson">íŒŒë¼ë¯¸í„°(JSON):</label>
                <textarea id="paramsJson" style="width:100%; height:120px; font-family: 'Courier New', monospace; font-size: 13px; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;" placeholder='ì˜ˆì‹œ:
{"id":"550e8400-e29b-41d4-a716-446655440000"}
{"username":"hong123"}
{"platform":"KAKAO"}
{"pageNo":0,"pageSize":10,"properties":"createdAt","direction":"DESC"}
{"username":"hong123","role":"ROLE_ADMIN"}
{"username":"hong123","role":"ROLE_USER","platform":"KAKAO"}
'></textarea>
            </div>
            <button onclick="callTool()" id="callToolBtn" disabled>Tool í˜¸ì¶œ</button>
            <div class="output" id="tool-output">Toolì„ ì„ íƒí•˜ê³  í˜¸ì¶œí•˜ì„¸ìš”.</div>
        </div>
    </div>
        
    <script>
        // Streamable-HTTP client replacing SSE
        let reader = null;
        let abortController = null;
        let sessionId = null;
        let rpcEndpointUrl = null; // full endpoint (may include sessionId)
        let baseUrl = window.location.origin; // default to same origin
        let closed = false;

        function updateStatus(status, message) {
            const statusEl = document.getElementById('status');
            statusEl.className = 'status ' + status;
            statusEl.textContent = message;
        }

        async function safeParseJSON(response) {
            try {
                const text = await response.text();
                if (!text) return { __emptyBody: true, status: response.status };
                try {
                    return JSON.parse(text);
                } catch (e) {
                    return { __parseError: true, status: response.status, rawText: text };
                }
            } catch (e) {
                return { __readError: true, error: e.message };
            }
        }

        async function connectSSE() {
            // open streamable HTTP POST to /api/mcp
            disconnect();
            updateStatus('connecting', 'ğŸ”„ ì—°ê²° ì¤‘...');
            document.getElementById('connection-info').textContent = 'ìŠ¤íŠ¸ë¦¬ë° ì—°ê²°ì„ ì‹œë„í•˜ëŠ” ì¤‘...';
            closed = false;
            abortController = new AbortController();

            try {
                const res = await fetch(`${baseUrl}/api/mcp`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'mcp-protocol-version': '2024-11-05'
                    },
                    body: JSON.stringify({}),
                    signal: abortController.signal
                });

                if (!res.body) {
                    updateStatus('disconnected', 'âŒ ì„œë²„ê°€ ìŠ¤íŠ¸ë¦¬ë°ì„ ì œê³µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
                    document.getElementById('connection-info').textContent = 'ì„œë²„ê°€ ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µì„ ì œê³µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
                    return;
                }

                updateStatus('connected', 'âœ… ìŠ¤íŠ¸ë¦¼ ì—°ê²°ë¨');
                document.getElementById('connection-info').textContent = `âœ… ìŠ¤íŠ¸ë¦¼ ì—°ê²°ë¨ (HTTP ${res.status})`;

                reader = res.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (!closed) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });

                    const lines = buffer.split(/\r?\n/);
                    buffer = lines.pop();

                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (!trimmed) continue;
                        try {
                            const msg = JSON.parse(trimmed);
                            handleStreamMessage(msg);
                        } catch (e) {
                            console.log('[LOG] non-json chunk:', trimmed.slice(0,200));
                        }
                    }
                }

                updateStatus('disconnected', 'ğŸ”Œ ì„œë²„ê°€ ìŠ¤íŠ¸ë¦¼ì„ ë‹«ì•˜ìŠµë‹ˆë‹¤');
                document.getElementById('connection-info').textContent = 'ì„œë²„ê°€ ìŠ¤íŠ¸ë¦¼ì„ ë‹«ì•˜ìŠµë‹ˆë‹¤.';
            } catch (e) {
                if (e.name === 'AbortError') {
                    updateStatus('disconnected', 'ğŸ”Œ ì—°ê²° ì¤‘ë‹¨ë¨');
                    document.getElementById('connection-info').textContent = 'ì—°ê²°ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.';
                } else {
                    updateStatus('disconnected', 'âŒ ì—°ê²° ì˜¤ë¥˜');
                    document.getElementById('connection-info').textContent = 'ì—°ê²° ì˜¤ë¥˜: ' + e.message;
                }
            } finally {
                cleanupStream();
            }
        }

        function handleStreamMessage(msg) {
            // endpoint message contains URL the server wants us to use for RPC (may include sessionId)
            if (msg.endpoint) {
                rpcEndpointUrl = msg.endpoint;
                // extract sessionId
                try {
                    const urlObj = new URL(rpcEndpointUrl, baseUrl);
                    sessionId = urlObj.searchParams.get('sessionId');
                } catch (e) {
                    const m = String(rpcEndpointUrl).match(/sessionId=([a-f0-9-]+)/i);
                    sessionId = m ? m[1] : null;
                }
                updateStatus('connected', 'âœ… ì—°ê²°ë¨ - Session ID: ' + (sessionId || 'unknown'));
                document.getElementById('connection-info').textContent = 'Endpoint: ' + rpcEndpointUrl + '\nSession ID: ' + sessionId;
                document.getElementById('listToolsBtn').disabled = false;
                document.getElementById('callToolBtn').disabled = false;
                // send initialize flow
                init().catch(e => console.warn('init error', e));
                return;
            }

            // handle JSON-RPC messages
            if (msg.jsonrpc || msg.method || msg.result || msg.error) {
                // if tools list result, update tools output
                const tools = (msg.result && msg.result.tools) || msg.tools || [];
                if (Array.isArray(tools) && tools.length) {
                    let output = 'ğŸ“‹ ë“±ë¡ëœ Tool ëª©ë¡:\n\n';
                    tools.forEach((tool, index) => {
                        output += `${index + 1}. ${tool.name}\n`;
                        if (tool.description) output += `   ì„¤ëª…: ${tool.description}\n`;
                        const props = tool.inputSchema && tool.inputSchema.properties
                            ? Object.keys(tool.inputSchema.properties) : [];
                        if (props.length) output += `   íŒŒë¼ë¯¸í„°: ${props.join(', ')}\n`;
                        output += '\n';
                    });
                    document.getElementById('tools-output').textContent = output;
                }
                // also log raw
                console.log('[LOG] RPC message:', msg);
                return;
            }

            console.log('[LOG] stream message:', msg);
        }

        function cleanupStream() {
            if (reader) {
                try { reader.cancel(); } catch(_) {}
                reader = null;
            }
            if (abortController) {
                try { abortController.abort(); } catch(_) {}
                abortController = null;
            }
        }

        function disconnect() {
            closed = true;
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            if (reader) {
                try { reader.cancel(); } catch(_) {}
                reader = null;
            }
            sessionId = null;
            rpcEndpointUrl = null;
            updateStatus('disconnected', 'âŒ ì—°ê²° í•´ì œë¨');
            document.getElementById('connection-info').textContent = 'ì—°ê²°ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.';
            document.getElementById('listToolsBtn').disabled = true;
            document.getElementById('callToolBtn').disabled = true;
        }

        async function init() {
            await sendRPC('initialize', {
                protocolVersion: '2024-11-05',
                capabilities: {},
                clientInfo: { name: 'Test', version: '1.0' }
            });
            await sendRPC('notifications/initialized');
        }

        async function sendRPC(method, params = {}) {
            const url = rpcEndpointUrl || `${baseUrl}/api/mcp?sessionId=${encodeURIComponent(sessionId || '')}`;
            const body = {
                jsonrpc: '2.0',
                method: method,
                ...(Object.keys(params).length && { params }),
                ...(method !== 'notifications/initialized' && { id: Date.now() })
            };
            try {
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                return await safeParseJSON(res);
            } catch (e) {
                console.warn('[LOG] sendRPC error', e);
                return null;
            }
        }

        async function listTools() {
            if (!sessionId) { alert('ë¨¼ì € ì—°ê²°í•˜ì„¸ìš”.'); return; }
            document.getElementById('tools-output').textContent = 'â³ Tool ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘...';
            try {
                await init();
                await sendRPC('tools/list', {});
                // response will arrive on stream and handleStreamMessage will update UI
            } catch (e) {
                document.getElementById('tools-output').textContent = 'âŒ ì˜¤ë¥˜ ë°œìƒ:\n' + (e.message || String(e));
            }
        }

        function updateInputs() {
            const toolSelect = document.getElementById('toolSelect');
            const paramsInput = document.getElementById('paramsInput');
            const noArgTools = new Set(['MyFirstToolWorks','getAllUsers']);
            if (!toolSelect.value || noArgTools.has(toolSelect.value)) {
                paramsInput.style.display = 'none';
            } else {
                paramsInput.style.display = 'block';
            }
        }

        async function callTool() {
            if (!sessionId) { alert('ë¨¼ì € ì—°ê²°í•˜ì„¸ìš”.'); return; }
            const toolSelect = document.getElementById('toolSelect');
            const toolName = toolSelect.value;
            if (!toolName) { alert('Toolì„ ì„ íƒí•˜ì„¸ìš”'); return; }
            document.getElementById('tool-output').textContent = 'â³ Tool í˜¸ì¶œ ì¤‘...';
            let args = {};
            const paramsInput = document.getElementById('paramsInput');
            const paramsJson = document.getElementById('paramsJson');
            if (paramsInput.style.display !== 'none' && paramsJson.value.trim()) {
                try { args = JSON.parse(paramsJson.value); } catch (e) { document.getElementById('tool-output').textContent = 'âŒ íŒŒë¼ë¯¸í„° JSON íŒŒì‹± ì˜¤ë¥˜: ' + e.message; return; }
            }

            try {
                const resp = await sendRPC('tools/call', { name: toolName, arguments: args });
                if (!resp) { document.getElementById('tool-output').textContent = 'âŒ ì‘ë‹µ ì—†ìŒ'; return; }
                if (resp.__parseError) { document.getElementById('tool-output').textContent = 'âŒ JSON íŒŒì‹± ì˜¤ë¥˜:\n' + resp.rawText; return; }

                let output = `ğŸ¯ Tool í˜¸ì¶œ ê²°ê³¼: ${toolName}\n\n`;
                if (resp.result && resp.result.content) {
                    output += 'âœ… ê²°ê³¼:\n';
                    resp.result.content.forEach(item => { if (item.type === 'text') output += item.text + '\n'; });
                } else if (resp.error) {
                    output += 'âŒ ì˜¤ë¥˜:\n' + JSON.stringify(resp.error, null, 2);
                } else {
                    output += 'ì „ì²´ ì‘ë‹µ:\n' + JSON.stringify(resp, null, 2);
                }
                document.getElementById('tool-output').textContent = output;
            } catch (e) {
                document.getElementById('tool-output').textContent = 'âŒ ì˜¤ë¥˜ ë°œìƒ:\n' + (e.message || String(e));
            }
        }
    </script>

</body>
</html>