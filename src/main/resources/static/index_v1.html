<!-- html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Tool Test UI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        .status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
        }
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        .status.connecting {
            background: #fff3cd;
            color: #856404;
        }
        .section {
            margin-bottom: 30px;
        }
        .section h2 {
            color: #555;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }
        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
            font-size: 14px;
        }
        .input-group select,
        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        .input-group select:focus,
        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        .output {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            min-height: 150px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .tool-item {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
        }
        .tool-name {
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }
        .tool-description {
            color: #666;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ› ï¸ MCP Tool Test UI</h1>
        <p class="subtitle">Spring AI MCP Server í…ŒìŠ¤íŠ¸ ì¸í„°í˜ì´ìŠ¤</p>

        <div id="status" class="status disconnected">
            âŒ ì—°ê²° ì•ˆë¨
        </div>

        <div class="section">
            <h2>1ï¸âƒ£ ì—°ê²° ì„¤ì •</h2>
            <button onclick="connectSSE()">SSE ì—°ê²°</button>
            <button onclick="disconnect()">ì—°ê²° í•´ì œ</button>
            <div class="output" id="connection-info">ì—°ê²°ì„ ì‹œì‘í•˜ë ¤ë©´ 'SSE ì—°ê²°' ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.</div>
        </div>

        <div class="section">
            <h2>2ï¸âƒ£ Tool ëª©ë¡ ì¡°íšŒ</h2>
            <button onclick="listTools()" id="listToolsBtn" disabled>Tool ëª©ë¡ ë³´ê¸°</button>
            <div class="output" id="tools-output">ì—°ê²° í›„ Tool ëª©ë¡ì„ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</div>
        </div>

        <div class="section">
            <h2>3ï¸âƒ£ Tool í˜¸ì¶œ í…ŒìŠ¤íŠ¸</h2>
            <div class="input-group">
                <label for="toolSelect">Tool ì„ íƒ:</label>
                <select id="toolSelect" onchange="updateInputs()">
                    <option value="">-- Toolì„ ì„ íƒí•˜ì„¸ìš” --</option>
                    <option value="MyFirstToolWorks">MyFirstToolWorks (íŒŒë¼ë¯¸í„° ì—†ìŒ)</option>
                    <option value="getAllUsers">getAllUsers (íŒŒë¼ë¯¸í„° ì—†ìŒ)</option>
                    <option value="getPaginatedUsers">getPaginatedUsers (pageNo,pageSize,properties,direction)</option>
                    <option value="getUserById">getUserById (id)</option>
                    <option value="getUserByUsername">getUserByUsername (username)</option>
                    <option value="getUsersByPlatform">getUsersByPlatform (platform)</option>
                    <option value="removeUserById">removeUserById (id)</option>
                    <option value="removeUserByUsername">removeUserByUsername (username)</option>
                    <option value="createUser">createUser (UserRequestDTO)</option>
                    <option value="changeUserRole">changeUserRole (UserRequestDTO)</option>
                    <option value="checkUserExists">checkUserExists (username)</option>
                </select>
            </div>
            
            <div class="input-group" id="paramsInput" style="display:none;">
                <label for="paramsJson">íŒŒë¼ë¯¸í„°(JSON):</label>
                <textarea id="paramsJson" style="width:100%; height:120px; font-family: 'Courier New', monospace; font-size: 13px; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;" placeholder='ì˜ˆì‹œ:
{"id":"550e8400-e29b-41d4-a716-446655440000"}
{"username":"hong123"}
{"platform":"KAKAO"}
{"pageNo":0,"pageSize":10,"properties":"createdAt","direction":"DESC"}
{"username":"hong123","role":"ROLE_ADMIN"}
{"username":"hong123","role":"ROLE_USER","platform":"KAKAO"}
'></textarea>
            </div>
            <button onclick="callTool()" id="callToolBtn" disabled>Tool í˜¸ì¶œ</button>
            <div class="output" id="tool-output">Toolì„ ì„ íƒí•˜ê³  í˜¸ì¶œí•˜ì„¸ìš”.</div>
        </div>
    </div>
	    
	<script>
	    let eventSource = null;
	    let sessionId = null;
	    let rpcEndpointUrl = null; // use server-provided endpoint
	
	    function updateStatus(status, message) {
	        const statusEl = document.getElementById('status');
	        statusEl.className = 'status ' + status;
	        statusEl.textContent = message;
	    }

	    // Helper: safely parse response body to JSON, handle empty/invalid bodies
	    async function safeParseJSON(response) {
	        try {
	            const text = await response.text();
	            if (!text) return { __emptyBody: true, status: response.status };
	            try {
	                return JSON.parse(text);
	            } catch (e) {
	                return { __parseError: true, status: response.status, rawText: text };
	            }
	        } catch (e) {
	            return { __readError: true, error: e.message };
	        }
	    }
	
	    function connectSSE() {
	        if (eventSource) {
	            eventSource.close();
	        }
	
	        console.log('[LOG] SSE ì—°ê²° ì‹œì‘');
	        updateStatus('connecting', 'ğŸ”„ ì—°ê²° ì¤‘...');
	        document.getElementById('connection-info').textContent = 'SSE ì—°ê²°ì„ ì‹œë„í•˜ëŠ” ì¤‘...';
	
	        eventSource = new EventSource('/sse');
	
	        eventSource.onopen = () => {
	            console.log('[LOG] SSE ì—°ê²° ì—´ë¦¼');
	        };
	
	        eventSource.addEventListener('endpoint', (event) => {
	            console.log('[LOG] endpoint ì´ë²¤íŠ¸ ë°›ìŒ:', event.data);
	            const endpoint = event.data;
	
	            // store full RPC endpoint URL (includes \?sessionId=...)
	            rpcEndpointUrl = endpoint;
	
	            // keep extracting sessionId for display only
	            const urlParams = new URLSearchParams(endpoint.split('?')[1] || '');
	            sessionId = urlParams.get('sessionId');
	
	            console.log('[LOG] ì¶”ì¶œëœ sessionId:', sessionId);
	            console.log('[LOG] RPC endpoint URL:', rpcEndpointUrl);
	            updateStatus('connected', 'âœ… ì—°ê²°ë¨ - Session ID: ' + sessionId);
	            document.getElementById('connection-info').textContent =
	                'âœ… SSE ì—°ê²° ì„±ê³µ!\n\n' +
	                'Endpoint: ' + endpoint + '\n' +
	                'Session ID: ' + sessionId;
	
	            document.getElementById('listToolsBtn').disabled = false;
	            document.getElementById('callToolBtn').disabled = false;
	        });

	        eventSource.addEventListener('message', (e) => {
	            console.log('[LOG] SSE message ì´ë²¤íŠ¸:', e.data);

           		const data = JSON.parse(e.data);
           		const tools = (data.result && data.result.tools) || data.tools || [];
   	            if (Array.isArray(tools) && tools.length) {
   	                let output = 'ğŸ“‹ ë“±ë¡ëœ Tool ëª©ë¡:\n\n';
   	                tools.forEach((tool, index) => {
   	                    output += `${index + 1}. ${tool.name}\n`;
   	                    if (tool.description) output += `   ì„¤ëª…: ${tool.description}\n`;
   	                    const props = tool.inputSchema && tool.inputSchema.properties
   	                        ? Object.keys(tool.inputSchema.properties) : [];
   	                    if (props.length) output += `   íŒŒë¼ë¯¸í„°: ${props.join(', ')}\n`;
   	                    output += '\n';
   	                });
   	                document.getElementById('tools-output').textContent = output;
   	            } else {
   	                document.getElementById('tools-output').textContent =
   	                    'âŒ Tool ëª©ë¡ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\n' + JSON.stringify(data, null, 2);
   	            }
   	            
	            
	            if (!data) {
	                document.getElementById('tools-output').textContent =
	                    `âŒ ì‘ë‹µ ë³¸ë¬¸ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. HTTP ìƒíƒœ: ${response.status} ${response.statusText}`;
	                return;
	            }
	            if (data.__parseError) {
	                document.getElementById('tools-output').textContent =
	                    `âŒ JSON íŒŒì‹± ì˜¤ë¥˜. HTTP ìƒíƒœ: ${data.status}\n\nì›ë³¸ ì‘ë‹µ:\n` + data.rawText;
	                return;
	            }
	
            });
	
	        eventSource.onerror = (error) => {
	            console.error('[LOG] SSE ì—ëŸ¬:', error);
	            updateStatus('disconnected', 'âŒ ì—°ê²° ì‹¤íŒ¨');
	            document.getElementById('connection-info').textContent =
	                'âŒ ì—°ê²° ì˜¤ë¥˜ ë°œìƒ\n\n' +
	                'ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.';
	            eventSource.close();
	            eventSource = null;
	            sessionId = null;
	            rpcEndpointUrl = null;
	            document.getElementById('listToolsBtn').disabled = true;
	            document.getElementById('callToolBtn').disabled = true;
	        };
	    }
	
	    function disconnect() {
	        if (eventSource) {
	            eventSource.close();
	            eventSource = null;
	            sessionId = null;
	            rpcEndpointUrl = null;
	            updateStatus('disconnected', 'âŒ ì—°ê²° í•´ì œë¨');
	            document.getElementById('connection-info').textContent = 'ì—°ê²°ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.';
	            document.getElementById('listToolsBtn').disabled = true;
	            document.getElementById('callToolBtn').disabled = true;
	        }
	    }
	    
	    async function init(method='initialize') {
	    	const url = rpcEndpointUrl || `/mcp/message?sessionId=${encodeURIComponent(sessionId)}`;
	    	const body = {
	    			jsonrpc: '2.0',
	    			method: 'initialize',
	    			protocolVersion: '2024-11-05',
	    			capabilities: {},
	    			clientInfo: { name: 'Test', version: '1.0' },
	    			...(method !== 'notifications/initialized' && { id: Date.now() })
	    	}
	    	try {
		    	const res = await fetch(url, {
	        		method: 'POST',
	        		headers: { 'Content-Type': 'application/json' },
	        		body: JSON.stringify(body)
	        	});
	        	// ignore body if empty
	        	await safeParseJSON(res);
	    	} catch (e) {
	    		console.warn('[LOG] init error', e);
	    	}
	    }
	    
	    async function notificationsInitialized(method) {
	    	const url = rpcEndpointUrl || `/mcp/message?sessionId=${encodeURIComponent(sessionId)}`;
	    	const body = {
	    			jsonrpc: '2.0',
	    			method: method,
	    			...(method !== 'notifications/initialized' && { id: Date.now() })
	    	}
	    	try {
		    	const res = await fetch(url, {
	        		method: 'POST',
	        		headers: { 'Content-Type': 'application/json' },
	        		body: JSON.stringify(body)
	        	});
	        	await safeParseJSON(res);
	    	} catch (e) {
	    		console.warn('[LOG] notificationsInitialized error', e);
	    	}
	    }
	
	    async function listTools() {
	        if (!sessionId) {
	            alert('ë¨¼ì € SSE ì—°ê²°ì„ í•´ì£¼ì„¸ìš”!');
	            return;
	        }
	
	        document.getElementById('tools-output').textContent = 'â³ Tool ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘...';
	
	        const requestBody = {
	            jsonrpc: '2.0',
	            id: Date.now(),
	            method: 'tools/list'
	        };
	
	        const url = rpcEndpointUrl || `/mcp/message?sessionId=${encodeURIComponent(sessionId)}`;
	        console.log('[LOG] tools/list POST ->', url);
	
	        try {
	        	await init();
	        	await notificationsInitialized('notifications/initialized');
	        	
	            const response = await fetch(url, {
	                method: 'POST',
	                headers: { 'Content-Type': 'application/json' },
	                body: JSON.stringify(requestBody)
	            });
	
	            console.log('[LOG] ì‘ë‹µ ë°›ìŒ:', response.status, response.statusText);
	            const data = await safeParseJSON(response);
	            console.log('[LOG] íŒŒì‹±ëœ ì‘ë‹µ ë°ì´í„°:', data);
	            
	            eventSource.addEventListener('message', (e) => {
	           		const data = JSON.parse(e.data);
	           		/*
	           		const tools = (data.result && data.result.tools) || data.tools || [];
	   	            if (Array.isArray(tools) && tools.length) {
	   	                let output = 'ğŸ“‹ ë“±ë¡ëœ Tool ëª©ë¡:\n\n';
	   	                tools.forEach((tool, index) => {
	   	                    output += `${index + 1}. ${tool.name}\n`;
	   	                    if (tool.description) output += `   ì„¤ëª…: ${tool.description}\n`;
	   	                    const props = tool.inputSchema && tool.inputSchema.properties
	   	                        ? Object.keys(tool.inputSchema.properties) : [];
	   	                    if (props.length) output += `   íŒŒë¼ë¯¸í„°: ${props.join(', ')}\n`;
	   	                    output += '\n';
	   	                });
	   	                document.getElementById('tools-output').textContent = output;
	   	            } else {
	   	                document.getElementById('tools-output').textContent =
	   	                    'âŒ Tool ëª©ë¡ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\n' + JSON.stringify(data, null, 2);
	   	            } */
	   	            
		            
		            if (!data) {
		                document.getElementById('tools-output').textContent =
		                    `âŒ ì‘ë‹µ ë³¸ë¬¸ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. HTTP ìƒíƒœ: ${response.status} ${response.statusText}`;
		                return;
		            }
		            if (data.__parseError) {
		                document.getElementById('tools-output').textContent =
		                    `âŒ JSON íŒŒì‹± ì˜¤ë¥˜. HTTP ìƒíƒœ: ${data.status}\n\nì›ë³¸ ì‘ë‹µ:\n` + data.rawText;
		                return;
		            }
					
	            });
	            
	        } catch (error) {
	            console.error('[LOG] ì—ëŸ¬ ë°œìƒ:', error);
	            document.getElementById('tools-output').textContent =
	                'âŒ ì˜¤ë¥˜ ë°œìƒ:\n\n' + (error.message || String(error));
	        }
	        console.log('[LOG] listTools() ì¢…ë£Œ');
	    }
	
	    function updateInputs() {
	        const toolSelect = document.getElementById('toolSelect');
	        const paramsInput = document.getElementById('paramsInput');
	        const noArgTools = new Set(['MyFirstToolWorks','getAllUsers']);
	        if (!toolSelect.value || noArgTools.has(toolSelect.value)) {
	            paramsInput.style.display = 'none';
	        } else {
	            paramsInput.style.display = 'block';
	        }
	    }
	
	    async function callTool() {
	        if (!sessionId) {
	            alert('ë¨¼ì € SSE ì—°ê²°ì„ í•´ì£¼ì„¸ìš”!');
	            return;
	        }
	
	        const toolSelect = document.getElementById('toolSelect');
	        const toolName = toolSelect.value;
	
	        if (!toolName) {
	            alert('Toolì„ ì„ íƒí•´ì£¼ì„¸ìš”!');
	            return;
	        }
	
	        document.getElementById('tool-output').textContent = 'â³ Tool í˜¸ì¶œ ì¤‘...';
	
	        let args = {};
	        const paramsInput = document.getElementById('paramsInput');
	        const paramsJson = document.getElementById('paramsJson');
	        if (paramsInput.style.display !== 'none' && paramsJson.value.trim()) {
	            try {
	                args = JSON.parse(paramsJson.value);
	            } catch (e) {
	                document.getElementById('tool-output').textContent = 'âŒ íŒŒë¼ë¯¸í„° JSON íŒŒì‹± ì˜¤ë¥˜: ' + e.message;
	                return;
	            }
	        }
	
	        const url = rpcEndpointUrl || `/mcp/message?sessionId=${encodeURIComponent(sessionId)}`;
	        console.log('[LOG] tools/call POST ->', url);
	
	        try {
	            const response = await fetch(url, {
	                method: 'POST',
	                headers: { 'Content-Type': 'application/json' },
	                body: JSON.stringify({
	                    jsonrpc: '2.0',
	                    id: 2,
	                    method: 'tools/call',
	                    params: { name: toolName, arguments: args }
	                })
	            });
				console.log('[LOG] ì‘ë‹µ ë°›ìŒ:', response.status, response.statusText);
	            const data = await safeParseJSON(response);
	
	            if (!data) {
	                document.getElementById('tool-output').textContent =
	                    `âŒ ì‘ë‹µ ë³¸ë¬¸ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. HTTP ìƒíƒœ: ${response.status} ${response.statusText}`;
	                return;
	            }
	            if (data.__parseError) {
	                document.getElementById('tool-output').textContent =
	                    `âŒ JSON íŒŒì‹± ì˜¤ë¥˜. HTTP ìƒíƒœ: ${data.status}\n\nì›ë³¸ ì‘ë‹µ:\n` + data.rawText;
	                return;
	            }
	
	            let output = `ğŸ¯ Tool í˜¸ì¶œ ê²°ê³¼: ${toolName}\n\n`;
	
	            if (data.result && data.result.content) {
	                output += 'âœ… ê²°ê³¼:\n';
	                data.result.content.forEach(item => {
	                    if (item.type === 'text') {
	                        output += item.text + '\n';
	                    }
	                });
	            } else if (data.error) {
	                output += 'âŒ ì˜¤ë¥˜:\n' + JSON.stringify(data.error, null, 2);
	            } else {
	                output += 'ì „ì²´ ì‘ë‹µ:\n' + JSON.stringify(data, null, 2);
	            }
	
	            document.getElementById('tool-output').textContent = output;
	        } catch (error) {
	            document.getElementById('tool-output').textContent =
	                'âŒ ì˜¤ë¥˜ ë°œìƒ:\n\n' + (error.message || String(error));
	        }
	    }
	</script>

</body>
</html>
