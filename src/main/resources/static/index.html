<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>MCP HTTP Test Client</title>
    <style>
		@font-face {
		    font-family: 'IbmPlexSans';
		    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_20-07@1.0/IBMPlexSansKR-Regular.woff') format('woff');
		    font-weight: normal;
		    font-display: swap;
		}
    
        body {
            font-family: 'IbmPlexSans', monospace;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        button {
        	font-family: inherit;
            padding: 8px 16px;
            margin: 4px;
            font-size: 17px;
            cursor: pointer;
            border-radius: 4px;
            border: 1px solid #555;
            background: #2d2d2d;
            color: #d4d4d4;
        }
        button.primary {
            background: #4FC3F7;
            color: #1e1e1e;
            border-color: #4FC3F7;
        }
        button.secondary {
            background: transparent;
            color: #d4d4d4;
            border-color: #666;
        }
        button:hover {
            opacity: 0.9;
        }
        input, textarea {
            font-family: inherit;
        }

        #logs {
            background: radial-gradient(circle at 10% 20%, #1c1c1c 0%, #0d0d0d 60%);
            padding: 16px;
            border-radius: 10px;
            margin-top: 20px;
            max-height: 420px;
            overflow-y: auto;
            font-size: 15px;
            border: 1px solid #2d2d2d;
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
        }
        .log {
            margin-bottom: 10px;
            border: 1px solid #2f2f2f;
            border-radius: 8px;
            padding: 10px 12px;
            background: linear-gradient(145deg, #151515, #1a1a1a);
        }
        .log-meta {
            font-size: 13px;
            color: #9d9d9d;
            letter-spacing: 0.2px;
        }
        .log-body {
            margin-top: 6px;
            white-space: pre-wrap;
            word-break: break-word;
            color: #e6e6e6;
        }
        .log-json {
            margin: 6px 0 0 0;
            padding: 10px 12px;
            background: #0e1116;
            border: 1px solid #243447;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'MemomentKkukKkuk', monospace;
            font-size: 15px;
            color: #cde3ff;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
        }
        .info { color: #4FC3F7; }
        .success { color: #81C784; }
        .error { color: #E57373; }

        #toolsSection { margin-top: 20px; }
        #toolsList {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 12px;
            margin-top: 10px;
        }
        .tool-card {
            background: #2d2d2d;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .tool-card h3 { margin: 0 0 4px 0; color: #81C784; font-size: 17px; }
        .tool-card p { margin: 0 0 8px 0; font-size: 15px; color: #aaa; }
        .tool-card button { width: 100%; }

        .section-title { margin-top: 24px; margin-bottom: 8px; }

        .param-group { margin-bottom: 10px; }
        .param-group label {
            display: block;
            margin-bottom: 4px;
            color: #81C784;
            font-size: 15px;
        }
        .param-group input,
        .param-group textarea {
            width: 100%;
            padding: 6px;
            margin: 0;
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #444;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 15px;
        }
        .param-group textarea { min-height: 80px; resize: vertical; }

        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
        }
        .modal-content {
            background: #2d2d2d;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
        }
        .modal-content h2 { margin-top: 0; }
        .modal-actions {
            margin-top: 16px;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
    </style>
</head>
<body>
<h1>MCP HTTP Test Client</h1>

<div>
    <input type="text" id="url" value="https://demeritorious-beverley-nonreadable.ngrok-free.dev" style="width:300px;padding:6px;" readonly>
    <button onclick="connect()">Connect</button>
    <button onclick="disconnect()">Reset</button>
</div>

<div id="toolsSection" style="display:none;">
    <div class="section-title" style="display:flex;align-items:center;justify-content:space-between;">
        <h2 style="margin:0;">Available Tools</h2>
        <button class="primary" onclick="openToolRegisterModal()">+ Register Tool</button>
    </div>
    <div id="toolsList"></div>
</div>

<h2 class="section-title">Logs</h2>
<div id="logs"></div>

<!-- Tool call modal -->
<div id="toolModal" class="modal">
    <div class="modal-content">
        <h2 id="modalToolName"></h2>
        <p id="modalToolDesc" style="font-size:15px;color:#ccc;"></p>
        <div id="modalParams"></div>
        <div class="modal-actions">
            <button class="secondary" onclick="closeModal()">Cancel</button>
            <button class="primary" onclick="executeToolCall()">Call</button>
        </div>
    </div>
</div>

<!-- Tool registration modal -->
<div id="toolRegisterModal" class="modal">
    <div class="modal-content">
        <h2>Register Tool</h2>
        <div class="param-group">
            <label for="toolName">name</label>
            <input id="toolName" type="text" placeholder="e.g. myDynamicTool">
        </div>
        <div class="param-group">
            <label for="toolDisplayName">displayName</label>
            <input id="toolDisplayName" type="text" placeholder="e.g. My Dynamic Tool">
        </div>
        <div class="param-group">
            <label for="toolDescription">description</label>
            <textarea id="toolDescription" placeholder="Describe what this tool does"></textarea>
        </div>
        <div class="param-group">
            <label for="toolType">toolType</label>
            <input id="toolType" type="text" placeholder="e.g. SCRIPT_JS or DSL">
        </div>
        <div class="param-group">
            <label for="toolLanguage">language</label>
            <input id="toolLanguage" type="text" placeholder="e.g. javascript">
        </div>
        <div class="param-group">
            <label for="toolDefinition">definition (script/DSL)</label>
            <textarea id="toolDefinition" placeholder="Paste the script or DSL definition here"></textarea>
        </div>
        <div class="param-group">
            <label for="toolParameterSchema">parameterSchema (JSON)</label>
            <textarea id="toolParameterSchema" placeholder='e.g. {"type":"object","properties":{...}}'></textarea>
        </div>
        <div class="param-group">
            <label for="toolTimeout">timeoutMs</label>
            <input id="toolTimeout" type="number" placeholder="e.g. 10000">
        </div>
        <div class="modal-actions">
            <button class="secondary" onclick="closeToolRegisterModal()">Cancel</button>
            <button class="primary" onclick="registerTool()">Register</button>
        </div>
    </div>
</div>

<script>
    let availableTools = [];
    let currentTool = null;
    let mcpSessionId = null;

    function log(msg, type = 'info') {
        const logs = document.getElementById('logs');
        const container = document.createElement('div');
        container.className = `log ${type}`;

        const meta = document.createElement('div');
        meta.className = 'log-meta';
        meta.textContent = `[${new Date().toLocaleTimeString()}] ${type.toUpperCase()}`;
        container.appendChild(meta);

        const body = document.createElement('div');
        body.className = 'log-body';

        const jsonObj = normalizeToJson(msg);
        if (jsonObj) {
            const pre = document.createElement('pre');
            pre.className = 'log-json';
            pre.textContent = JSON.stringify(jsonObj, null, 2);
            body.appendChild(pre);
        } else {
            body.textContent = typeof msg === 'string' ? msg : String(msg);
        }

        container.appendChild(body);
        logs.appendChild(container);
        logs.scrollTop = logs.scrollHeight;
    }

    function normalizeToJson(msg) {
        if (msg === null || msg === undefined) return null;
        if (typeof msg === 'object') return msg;
        if (typeof msg === 'string') {
            const trimmed = msg.trim();
            if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
                try {
                    return JSON.parse(trimmed);
                } catch (e) {
                    return null;
                }
            }
        }
        return null;
    }

    async function sendMCP(method, params = {}) {
        const base = document.getElementById('url').value.trim();
        if (!base) {
            log('먼저 MCP URL을 입력해주세요!', 'error');
            return null;
        }

        const url = `${base}/mcp`;
        const body = {
            jsonrpc: '2.0',
            id: Date.now(),
            method,
            ...(Object.keys(params).length > 0 && { params })
        };

        log(`요청 전송: ${method}`, 'info');

        try {
            const headers = {
                'Accept': 'application/json, text/event-stream',
                'Content-Type': 'application/json',
                'mcp-protocol-version': '2025-06-18'
            };
            if (mcpSessionId) {
                headers['mcp-session-id'] = mcpSessionId;
            }

            const res = await fetch(url, {
                method: 'POST',
                headers,
                body: JSON.stringify(body)
            });
            console.log(`${method} 응답 객체:`, res);
            let parsed;
            if (method === 'initialize') {
                const sessionFromHeader = res.headers.get('Mcp-Session-Id') || res.headers.get('mcp-session-id');
                if (sessionFromHeader && !mcpSessionId) {
                    mcpSessionId = sessionFromHeader;
                }
                log(`응답 상태: ${res.status}`, res.ok ? 'success' : 'error');
            } else if (method === 'tools/list' || method === 'tools/call') {
                const text = await res.text();
                const match = text.match(/^data:\s*(.*)$/m);
                if (!match) {
                    console.log('data 라인을 찾지 못했습니다.');
                    console.log(text);
                    log('도구 목록/호출 응답 형식이 올바르지 않습니다.', 'error');
                    return null;
                }
                const jsonStr = match[1];
                parsed = JSON.parse(jsonStr);
                log(`응답 상태: ${res.status}`, res.ok ? 'success' : 'error');
                if (method === 'tools/call' && parsed.result && parsed.result.content) {
	                log(parsed, res.ok ? 'success' : 'error');
                    console.log('도구 응답:', parsed);
                }
                return parsed;
            } else {
                parsed = await res.json();
                console.log(`${method} 응답 JSON:`, parsed);
                log(`응답 상태: ${res.status}`, res.ok ? 'success' : 'error');
                log(parsed, res.ok ? 'success' : 'error');
                return parsed;
            }
        } catch (e) {
            log(`HTTP 오류 발생: ${e}`, 'error');
            return null;
        }
    }

    async function init() {
        await sendMCP('initialize', {
            protocolVersion: '2024-11-05',
            capabilities: {},
            clientInfo: { name: 'TestClient', version: '1.0' }
        });
        const toolsResp = await sendMCP('tools/list');
        if (toolsResp && toolsResp.result && toolsResp.result.tools) {
            availableTools = toolsResp.result.tools;
            log('도구 목록을 성공적으로 불러왔어요', 'success');
            log(`총 ${availableTools.length}개의 도구를 찾았어요`, 'success');
            displayTools(availableTools);
            //log(toolsResp, 'info');
        }
    }

    function connect() {
        init();
    }

    function disconnect() {
        availableTools = [];
        currentTool = null;
        document.getElementById('toolsSection').style.display = 'none';
        document.getElementById('toolsList').innerHTML = '';
        log('연결/세션 상태가 초기화되었어요', 'info');
    }

    function displayTools(tools) {
        const section = document.getElementById('toolsSection');
        const list = document.getElementById('toolsList');
        list.innerHTML = '';

        if (!tools || tools.length === 0) {
            section.style.display = 'none';
            return;
        }

        section.style.display = 'block';

        tools.forEach((tool) => {
            const card = document.createElement('div');
            card.className = 'tool-card';

            const title = document.createElement('h3');
            title.textContent = tool.name;
            card.appendChild(title);

            const desc = document.createElement('p');
            desc.textContent = tool.description || '';
            card.appendChild(desc);

            const btn = document.createElement('button');
            btn.textContent = 'Call Tool';
            btn.onclick = () => openToolModal(tool);
            card.appendChild(btn);

            list.appendChild(card);
        });
    }

    function openToolModal(tool) {
        currentTool = tool;
        document.getElementById('modalToolName').textContent = tool.name;
        document.getElementById('modalToolDesc').textContent = tool.description || '';

        const paramsDiv = document.getElementById('modalParams');
        paramsDiv.innerHTML = '';

        const schema = tool.inputSchema;
        if (schema && schema.properties) {
            Object.entries(schema.properties).forEach(([key, prop]) => {
                const group = document.createElement('div');
                group.className = 'param-group';

                const label = document.createElement('label');
                label.textContent = `${key} (${prop.type || 'any'})`;
                group.appendChild(label);

                const input = document.createElement('textarea');
                input.id = `param_${key}`;
                input.placeholder = prop.description || '';
                input.rows = 1;
                group.appendChild(input);

                paramsDiv.appendChild(group);
            });
        } else {
            const info = document.createElement('p');
            info.textContent = '이 도구는 입력 파라미터가 필요하지 않아요';
            paramsDiv.appendChild(info);
        }

        document.getElementById('toolModal').style.display = 'block';
    }

    function closeModal() {
        document.getElementById('toolModal').style.display = 'none';
        currentTool = null;
    }

    function openToolRegisterModal() {
        document.getElementById('toolRegisterModal').style.display = 'block';
    }

    function closeToolRegisterModal() {
        document.getElementById('toolRegisterModal').style.display = 'none';
    }

    async function executeToolCall() {
        if (!currentTool) {
            log('먼저 호출할 도구를 선택해주세요', 'error');
            return;
        }

        const params = {};
        const paramsDiv = document.getElementById('modalParams');
        const inputs = paramsDiv.querySelectorAll('textarea');

        let hasError = false;
        inputs.forEach((input) => {
            if (hasError) return;

            const key = input.id.replace('param_', '');
            const value = input.value.trim();
            if (!value) return;

            const prop = currentTool.inputSchema?.properties?.[key];
            if (!prop || !prop.type || prop.type === 'string') {
                params[key] = value;
            } else if (prop.type === 'number' || prop.type === 'integer') {
                const num = Number(value);
                if (Number.isNaN(num)) {
                    log(`필드 ${key}는 숫자여야 해요!`, 'error');
                    hasError = true;
                } else {
                    params[key] = num;
                }
            } else if (prop.type === 'boolean') {
                params[key] = value === 'true' || value === '1';
            } else if (prop.type === 'object' || prop.type === 'array') {
                try {
                    params[key] = JSON.parse(value);
                } catch (e) {
                    log(`필드 ${key} JSON 파싱 오류: ${e.message}`, 'error');
                    hasError = true;
                }
            } else {
                params[key] = value;
            }
        });

        if (hasError) return;

        const toolName = currentTool.name;
        closeModal();

        log(`도구 실행: ${toolName}`, 'info');
        const resp = await sendMCP('tools/call', {
            name: toolName,
            arguments: params
        });

        if (resp) {
            log(resp, 'info');
        }

        if (resp && resp.result && resp.result.content) {
            log('도구 실행 결과:', 'success');
            resp.result.content.forEach((c) => {
                if (c.text) {
                    log(c.text, 'info');
                }
            });
        }
    }

    async function registerTool() {
        const base = window.location.origin;
        const rawSchema = document.getElementById('toolParameterSchema').value.trim();

        const payload = {
            name: document.getElementById('toolName').value.trim(),
            displayName: document.getElementById('toolDisplayName').value.trim(),
            description: document.getElementById('toolDescription').value.trim(),
            toolType: document.getElementById('toolType').value.trim(),
            language: document.getElementById('toolLanguage').value.trim(),
            definition: document.getElementById('toolDefinition').value,
            parameterSchema: rawSchema.length > 0 ? rawSchema : null,
            timeoutMs: document.getElementById('toolTimeout').value
                ? parseInt(document.getElementById('toolTimeout').value, 10)
                : null,
            enabled: true,
            version: 1
        };

        try {
            const res = await fetch(`${base}/api/tools`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!res.ok) {
                const text = await res.text();
                log(`도구 등록 실패: ${res.status} ${text}`, 'error');
                return;
            }

            const created = await res.json();
            log(`새 도구 등록 완료: ${created.name}`, 'success');
            log(created, 'success');
            closeToolRegisterModal();
        } catch (e) {
            log(`도구 등록 오류: ${e}`, 'error');
        }
    }

    // Close modals when clicking outside
    window.onclick = function (event) {
        const toolModal = document.getElementById('toolModal');
        const registerModal = document.getElementById('toolRegisterModal');
        if (event.target === toolModal) {
            closeModal();
        } else if (event.target === registerModal) {
            closeToolRegisterModal();
        }
    };

    log('페이지 로딩 완료!', 'success');
</script>
</body>
</html>
